<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>2-Conduit (conduit-tls.Conduit_tls.Make.2-Conduit)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../index.html">conduit-tls</a> &#x00BB; <a href="../../index.html">Conduit_tls</a> &#x00BB; <a href="../index.html">Make</a> &#x00BB; 2-Conduit</nav><h1>Parameter <code>Make.2-Conduit</code></h1><nav class="toc"><ul><li><a href="#client">Client-side conduits.</a></li><li><a href="#registration">Protocol registration.</a></li><li><a href="#injection-and-extraction.">Injection and Extraction.</a></li><li><a href="#resolution">Domain name resolvers.</a></li><li><a href="#service">Server-side conduits.</a></li></ul></nav></header><div class="spec module" id="module-Endpoint"><a href="#module-Endpoint" class="anchor"></a><code><span class="keyword">module</span> <a href="Endpoint/index.html">Endpoint</a> : <span class="keyword">module</span> <span class="keyword">type</span> <span class="keyword">of</span> <a href="../../../../conduit/Conduit/index.html#module-Endpoint">Conduit.Endpoint</a></code></div><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type</span> input</code><code> = Cstruct.t</code></dt><dd><p>The type for payload inputs.</p></dd></dl><dl><dt class="spec type" id="type-output"><a href="#type-output" class="anchor"></a><code><span class="keyword">type</span> output</code><code> = Cstruct.t</code></dt><dd><p>The type for payload outputs.</p></dd></dl><dl><dt class="spec type" id="type-io"><a href="#type-io" class="anchor"></a><code><span class="keyword">type</span> <span>+'a io</span></code><code> = <span><span class="type-var">'a</span> <a href="../argument-1-IO/index.html#type-t">IO.t</a></span></code></dt><dd><p>The type for I/O effects.</p></dd></dl><dl><dt class="spec type" id="type-scheduler"><a href="#type-scheduler" class="anchor"></a><code><span class="keyword">type</span> scheduler</code></dt><dd><p>The type of I/O monads.</p></dd></dl><section><header><h3 id="client"><a href="#client" class="anchor"></a>Client-side conduits.</h3></header><dl><dt class="spec type" id="type-flow"><a href="#type-flow" class="anchor"></a><code><span class="keyword">type</span> flow</code><code> = <span class="keyword">private</span> </code><code>..</code></dt><dd><p>The type for generic flows. <a href="module-type-PROTOCOL/index.html"><code>PROTOCOL</code></a> implementations are extending (via <a href="index.html#val-register"><code>register</code></a>) this type. It allows users to extract the underlying flow implementation:</p><pre><code class="ml">Conduit.connect domain_name &gt;&gt;? function
 | Conduit_lwt_unix_tcp.T Conduit.(Value (file_descr : Lwt_unix.file_descr)) -&gt; ...
 | Conduit_lwt_unix_tls.T Conduit.(Value (fd, (tls : Tls.Engine.state))) -&gt; ...
 | _ -&gt; ... (* use flow functions for the default case *)</code></pre></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Msg" class="anchored"><td class="def constructor"><a href="#type-error.Msg" class="anchor"></a><code>| </code><code>`Msg <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Not_found" class="anchored"><td class="def constructor"><a href="#type-error.Not_found" class="anchor"></a><code>| </code><code>`Not_found</code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <span><a href="index.html#type-error">error</a> Fmt.t</span></code></dt><dt class="spec value" id="val-recv"><a href="#val-recv" class="anchor"></a><code><span class="keyword">val</span> recv : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <span><span><span>(<span>[ <span>`Input of int</span> <span>| `End_of_flow</span> ]</span>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-io">io</a></span></code></dt><dd><p><code>recv flow input</code> is <code>Ok (`Input len)</code> iff <code>n</code> bytes of data has been received from the flow <code>flow</code> and copied in <code>input</code>.</p></dd></dl><dl><dt class="spec value" id="val-send"><a href="#val-send" class="anchor"></a><code><span class="keyword">val</span> send : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-output">output</a> <span>&#45;&gt;</span> <span><span><span>(int, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-io">io</a></span></code></dt><dd><p><code>send flow output</code> is <code>Ok n</code> iff <code>n</code> bytes of date from <code>output</code> has been sent over the flow <code>flow</code>.</p></dd></dl><dl><dt class="spec value" id="val-close"><a href="#val-close" class="anchor"></a><code><span class="keyword">val</span> close : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <span><span><span>(unit, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-io">io</a></span></code></dt><dd><p><code>close flow</code> closes <code>flow</code>. Subsequent calls to <a href="index.html#val-recv"><code>recv</code></a> will return <code>Ok `End_of_flow</code>. Subsequent calls to <a href="index.html#val-send"><code>send</code></a> will return an <code>Error</code>.</p></dd></dl></section><section><header><h3 id="registration"><a href="#registration" class="anchor"></a>Protocol registration.</h3></header><dl><dt class="spec module-type" id="module-type-FLOW"><a href="#module-type-FLOW" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html">FLOW</a> = <a href="../../../../conduit/Conduit__/Sigs/index.html#module-type-FLOW">Conduit__.Sigs.FLOW</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html#type-input">input</a> = <a href="index.html#type-input">input</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html#type-output">output</a> = <a href="index.html#type-output">output</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>+'a <a href="module-type-FLOW/index.html#type-io">io</a></span> = <span><span class="type-var">'a</span> <a href="index.html#type-io">io</a></span></code></dt><dd><p>A flow is a system that allows entities to transmit <i>payloads</i>. These entities do not have to care about the underlying transport mechanism. flows simply deal with routing and delivering of these payloads. That abstraction allows these protocols to compose.</p></dd></dl><dl><dt class="spec module-type" id="module-type-PROTOCOL"><a href="#module-type-PROTOCOL" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-PROTOCOL/index.html">PROTOCOL</a> = <a href="../../../../conduit/Conduit__/Sigs/index.html#module-type-PROTOCOL">Conduit__.Sigs.PROTOCOL</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-PROTOCOL/index.html#type-input">input</a> = <a href="index.html#type-input">input</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-PROTOCOL/index.html#type-output">output</a> = <a href="index.html#type-output">output</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>+'a <a href="module-type-PROTOCOL/index.html#type-io">io</a></span> = <span><span class="type-var">'a</span> <a href="index.html#type-io">io</a></span></code></dt><dd><p>A protocol is a <a href="module-type-FLOW/index.html"><code>FLOW</code></a> plus <code>connect</code>.</p></dd></dl><dl><dt class="spec type" id="type-impl"><a href="#type-impl" class="anchor"></a><code><span class="keyword">type</span> <span>('edn, 'flow) impl</span></code><code> = <span>(<span class="keyword">module</span> <a href="module-type-PROTOCOL/index.html">PROTOCOL</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-PROTOCOL/index.html#type-endpoint">endpoint</a> = <span class="type-var">'edn</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-PROTOCOL/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span></code></dt><dd><p>The type to represent a module <a href="module-type-PROTOCOL/index.html"><code>PROTOCOL</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-protocol"><a href="#type-protocol" class="anchor"></a><code><span class="keyword">type</span> <span>('edn, 'flow) protocol</span></code></dt><dd><p>The type for client protocols. <code>'edn</code> is the type for endpoint parameters. <code>'flow</code> is the type for underlying flows.</p><p>Endpoints allow users to create flows by either connecting directly to a remote server or by resolving domain names (with <a href="index.html#val-connect"><code>connect</code></a>).</p></dd></dl><dl><dt class="spec value" id="val-register"><a href="#val-register" class="anchor"></a><code><span class="keyword">val</span> register : <span>protocol:<span><span>(<span class="type-var">'edn</span>, <span class="type-var">'flow</span>)</span> <a href="index.html#type-impl">impl</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'edn</span>, <span class="type-var">'flow</span>)</span> <a href="index.html#type-protocol">protocol</a></span></code></dt><dd><p><code>register ~protocol</code> is the protocol using the implementation <code>protocol</code>. <code>protocol</code> must provide a <code>connect</code> function to allow client flows to be created.</p><p>For instance, on Unix, <code>Conduit</code> clients will use <code>Unix.sockaddr</code> as flow endpoints, while <code>Unix.file_descr</code> would be used for the flow transport.</p><pre><code class="ml">module Conduit_tcp : sig
  val t : (Unix.sockaddr, Unix.file_descr) protocol
end = struct
  let t = register ~protocol:(module TCP)
end</code></pre><p>Client endpoints can of course be more complex, for instance to hold TLS credentials, and <code>Conduit</code> allows all these kinds of flow to be used transparently:</p><pre><code class="ml">module Conduit_tcp_tls : sig
  val t : (Unix.sockaddr * Tls.Config.client, Unix.file_descr) protocol
end = struct
  let t = register ~protocol:(module TLS)
end</code></pre><p>As a protocol implementer, you must <i>register</i> your implementation and expose the <i>witness</i> of it. Then, users will be able to use it.</p></dd></dl></section><section><header><h3 id="injection-and-extraction."><a href="#injection-and-extraction." class="anchor"></a>Injection and Extraction.</h3><p>The goal of <code>Conduit</code> is to provide:</p><ul><li>A way to manipulate a fully-abstract <code>flow</code>.</li><li>A way to manipulate a concrete and well-know <code>flow</code>.</li></ul><p><code>Conduit</code> provides several mechanisms to be able to manipulate our abstract type <a href="index.html#type-flow"><code>flow</code></a> and destruct it to a concrete value such as a <code>Unix.file_descr</code>. <code>Conduit</code> can assert one assumption: from a given abstracted <code>flow</code>, it exists one and only one <a href="module-type-FLOW/index.html"><code>FLOW</code></a> implementation.</p><p>As <code>Conduit</code> determines this implementation, the user can determine the used implementation when he wants to <a href="index.html#val-send"><code>send</code></a> or <a href="index.html#val-recv"><code>recv</code></a> datas.</p><p>So <code>Conduit</code> uses or extracts uniqely the implementation registered before with <a href="index.html#val-register"><code>register</code></a> and no layer can tweak or update this assertion.</p><p><a href="index.html#val-repr"><code>repr</code></a>, <a href="index.html#type-flow"><code>flow</code></a>, <a href="index.html#type-impl"><code>impl</code></a> and <code>is</code> can extracts in differents ways the abstracted <a href="index.html#type-flow"><code>flow</code></a>:</p><ul><li>with the <i>pattern-matching</i></li><li>with <i>first-class module</i></li><li>with the function <code>is</code></li></ul></header><div class="spec module-type" id="module-type-REPR"><a href="#module-type-REPR" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-REPR/index.html">REPR</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-repr"><a href="#val-repr" class="anchor"></a><code><span class="keyword">val</span> repr : <span><span>(<span class="type-var">'edn</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-protocol">protocol</a></span> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-REPR/index.html">REPR</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-REPR/index.html#type-t">t</a> = <span><span>(<span class="type-var">'edn</span>, <span class="type-var">'v</span>)</span> <a href="../../../../conduit/Conduit/index.html#type-value">Conduit.value</a></span>)</span></code></dt><dd><p>As a protocol implementer, you should expose the concrete type of your flow (to be able users to <i>destruct</i> <a href="index.html#type-flow"><code>flow</code></a>). <code>repr</code> returns a module which contains extension of <a href="index.html#type-flow"><code>flow</code></a> from your <code>protocol</code> such as:</p><pre><code class="ml">module Conduit_tcp : sig
  type t = (Unix.sockaddr, Unix.file_descr) Conduit.value
  type Conduit.flow += T of t
  val t : (Unix.sockaddr, Unix.file_descr) protocol
end = struct
  let t = register ~protocol:(module TCP)
  include (val (Conduit.repr t))
end</code></pre><p>With this interface, users are able to <i>destruct</i> <a href="index.html#type-flow"><code>flow</code></a> to your concrete type:</p><pre><code class="ml">Conduit.connect domain_name &gt;&gt;? function
  | Conduit_tcp.T (Conduit.Value file_descr) -&gt; ...
  | _ -&gt; ...</code></pre></dd></dl><dl><dt class="spec type" id="type-unpack"><a href="#type-unpack" class="anchor"></a><code><span class="keyword">type</span> unpack</code><code> = </code><table class="variant"><tr id="type-unpack.Flow" class="anchored"><td class="def constructor"><a href="#type-unpack.Flow" class="anchor"></a><code>| </code><code><span class="constructor">Flow</span> : <span class="type-var">'flow</span> * <span>(<span class="keyword">module</span> <a href="module-type-FLOW/index.html">FLOW</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-unpack">unpack</a></code></td></tr></table></dt></dl><dl><dt class="spec value" id="val-unpack"><a href="#val-unpack" class="anchor"></a><code><span class="keyword">val</span> unpack : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <a href="index.html#type-unpack">unpack</a></code></dt><dd><p><code>pack flow</code> projects the module implementation associated to the given abstract <code>flow</code> such as:</p><pre><code class="ml">Conduit.connect edn &gt;&gt;= fun flow -&gt;
let Conduit.Flow (flow, (module Flow)) = Conduit.unpack flow in
Flow.send flow &quot;Hello World!&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-impl"><a href="#val-impl" class="anchor"></a><code><span class="keyword">val</span> impl : <span><span>(<span class="type-var">'edn</span>, <span class="type-var">'flow</span>)</span> <a href="index.html#type-protocol">protocol</a></span> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-PROTOCOL/index.html">PROTOCOL</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-PROTOCOL/index.html#type-endpoint">endpoint</a> = <span class="type-var">'edn</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-PROTOCOL/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span></code></dt><dd><p><code>impl protocol</code> is <code>protocol</code>'s implementation.</p></dd></dl><dl><dt class="spec value" id="val-cast"><a href="#val-cast" class="anchor"></a><code><span class="keyword">val</span> cast : <a href="index.html#type-flow">flow</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">_</span>, <span class="type-var">'flow</span>)</span> <a href="index.html#type-protocol">protocol</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'flow</span> option</span></code></dt><dd><p><code>cast flow protocol</code> tries to <i>cast</i> the given <code>flow</code> to the concrete type described by the given <code>protocol</code>.</p><pre><code class="ml">match Conduit.is flow Conduit_tcp.t with
| Some (file_descr : Unix.file_descr) -&gt; Some (Unix.getpeername file_descr)
| None -&gt; None</code></pre></dd></dl><dl><dt class="spec value" id="val-pack"><a href="#val-pack" class="anchor"></a><code><span class="keyword">val</span> pack : <span><span>(<span class="type-var">_</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-protocol">protocol</a></span> <span>&#45;&gt;</span> <span class="type-var">'v</span> <span>&#45;&gt;</span> <a href="index.html#type-flow">flow</a></code></dt><dd><p><code>pack protocol concrete_flow</code> abstracts the given <code>flow</code> into the <a href="index.html#type-flow"><code>flow</code></a> type from a given <code>protocol</code>. It permits to use <code>Conduit</code> with a concrete value created by the user.</p><pre><code class="ml">let socket = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
let flow = Conduit.pack Conduit_tcp.t socket in
Conduit.send flow &quot;Hello World!&quot;</code></pre></dd></dl></section><section><header><h3 id="resolution"><a href="#resolution" class="anchor"></a>Domain name resolvers.</h3></header><dl><dt class="spec type" id="type-resolver"><a href="#type-resolver" class="anchor"></a><code><span class="keyword">type</span> <span>'edn resolver</span></code><code> = <a href="../../../../conduit/Conduit/Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span class="type-var">'edn</span> option</span> <a href="index.html#type-io">io</a></span></code></dt><dd><p>The type for resolver functions, which resolve domain names to endpoints. For instance, the DNS resolver function is:</p><pre><code class="ml">let http_resolver : Unix.sockaddr resolver = function
  | IP ip -&gt; Some (Ipaddr_unix.to_inet_addr ip, 80)
  | Domain domain_name -&gt; match Unix.gethostbyname (Domain_name.to_string domain_name) with
    | { Unix.h_addr_list; _ } -&gt;
      if Array.length h_addr_list &gt; 0
      then Some (Unix.ADDR_INET (h_addr_list.(0), 80))
      else None
    | exception _ -&gt; None</code></pre></dd></dl><dl><dt class="spec type" id="type-resolvers"><a href="#type-resolvers" class="anchor"></a><code><span class="keyword">type</span> <span class="keyword">nonrec</span> resolvers</code><code> = <a href="../../../../conduit/Conduit/index.html#type-resolvers">Conduit.resolvers</a></code></dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-resolvers">resolvers</a></code></dt><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <span><span>(<span class="type-var">'edn</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-protocol">protocol</a></span> <span>&#45;&gt;</span> <span>?&#8288;priority:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'edn</span> <a href="index.html#type-resolver">resolver</a></span> <span>&#45;&gt;</span> <a href="index.html#type-resolvers">resolvers</a> <span>&#45;&gt;</span> <a href="index.html#type-resolvers">resolvers</a></code></dt><dd><p><code>add protocol ?priority resolver resolvers</code> adds a new resolver function <code>resolver</code> to <code>resolvers</code>.</p><p>When the <code>resolver</code> is able to resolve the given domain name, it will try to connect to the specified client endpoint. Resolvers are iterated in priority order (lower to higher).</p><pre><code class="ml">let http_resolver = ...
let https_resolver = ... (* deal with client-side certificates here. *)

let resolvers =
  empty
  |&gt; add Conduit_tcp.t http_resolver
  |&gt; add Conduit_tcp_tls.t https_resolver ~priority:10
  |&gt; add Conduit_tcp_ssl.t https_resolver ~priority:20</code></pre></dd></dl><dl><dt class="spec value" id="val-resolve"><a href="#val-resolve" class="anchor"></a><code><span class="keyword">val</span> resolve : <a href="index.html#type-resolvers">resolvers</a> <span>&#45;&gt;</span> <span>?&#8288;protocol:<span><span>(<span class="type-var">'edn</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-protocol">protocol</a></span></span> <span>&#45;&gt;</span> <a href="../../../../conduit/Conduit/Endpoint/index.html#type-t">Endpoint.t</a> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-flow">flow</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-io">io</a></span></code></dt><dd><p><code>resolve resolvers domain_name</code> is the flow created by connecting to the domain name <code>domain_name</code>, using the resolvers <code>resolvers</code>. Each resolver tries to resolve the given domain-name (they are ordered by the given priority). The first which connects successfully wins.</p><p>The resolver result is a flow connect to that winning endpoint.</p><pre><code class="ml">let mirage_io = domain_name_exn &quot;mirage.io&quot;

val resolver_on_my_private_network : Unix.sockaddr resolver
val resolver_on_internet : Unix.sockaddr resolver
val resolver_with_tls : (Unix.sockaddr * Tls.Config.client) resolver

let resolvers =
  empty
  |&gt; add tls ~priority:0 resolver_with_tls
  |&gt; add tcp ~priority:10 resolver_on_my_private_network
  |&gt; add tcp ~priority:20 resolver_on_internet

let () = Conduit.resolve resolvers (Conduit.Endpoint.domain mirage_io) &gt;&gt;? function
  | TCP.T (Conduit.Value file_descr) as flow -&gt;
    let peer = Unix.getpeername file_descr in
    ignore @@ Conduit.send flow (&quot;Hello &quot; ^ string_of_sockaddr peer)
  | flow -&gt;
    ignore @@ Conduit.send flow &quot;Hello World!&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-connect"><a href="#val-connect" class="anchor"></a><code><span class="keyword">val</span> connect : <span class="type-var">'edn</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'edn</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-protocol">protocol</a></span> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-flow">flow</a>, <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-io">io</a></span></code></dt></dl></section><section><header><h3 id="service"><a href="#service" class="anchor"></a>Server-side conduits.</h3></header><div class="spec module-type" id="module-type-SERVICE"><a href="#module-type-SERVICE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SERVICE/index.html">SERVICE</a> = <a href="../../../../conduit/Conduit__/Sigs/index.html#module-type-SERVICE">Conduit__.Sigs.SERVICE</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>+'a <a href="module-type-SERVICE/index.html#type-io">io</a></span> = <span><span class="type-var">'a</span> <a href="index.html#type-io">io</a></span></code></div><div class="spec module" id="module-Service"><a href="#module-Service" class="anchor"></a><code><span class="keyword">module</span> <a href="Service/index.html">Service</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section></div></body></html>