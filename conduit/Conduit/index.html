<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Conduit (conduit.Conduit)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">conduit</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Conduit</span></h1></header><p>Interface for establishing reliable stream-oriented connections.</p><p>This library abstracts the concerns of establishing connections to
peers that may be running within the same host (e.g. in another
virtual machine) or on a remote host via TCP. It consists of one
library that is responsible for <a href="index.html#transport">establishing individual
connections</a>, and a <a href="index.html#resolution">name resolver</a> that maps URIs
to endpoints.</p><h3 id="transport" class="anchored"><a href="#transport" class="anchor"></a>Connection Establishment</h3><p>Connections are created by identifying remote nodes using an
<a href="index.html#type-endp">endp</a> value. To ensure portability, the <a href="index.html#type-endp">endp</a> values
are translated into concrete connections by separate modules that
target <code class="code">Lwt_unix</code>, <code class="code">Async</code> and <code class="code">Mirage</code>. This lets those backends
use the appropriate local technique for creating the connection
(such as using OpenSSL on Unix, or a pure OCaml TLS+TCP
implementation on Mirage, or some other combination).</p><p>The modules dealing with connection establishment are:
</p><table class="modules"><tr id="listing-xref-unresolved-Conduit_lwt_unix" class="anchored"><td class="xref-unresolved"><a href="#listing-xref-unresolved-Conduit_lwt_unix" class="anchor"></a>Conduit_lwt_unix</td><td class="doc"></td></tr><tr id="listing-xref-unresolved-Conduit_async" class="anchored"><td class="xref-unresolved"><a href="#listing-xref-unresolved-Conduit_async" class="anchor"></a>Conduit_async</td><td class="doc"></td></tr><tr id="listing-xref-unresolved-Conduit_mirage" class="anchored"><td class="xref-unresolved"><a href="#listing-xref-unresolved-Conduit_mirage" class="anchor"></a>Conduit_mirage</td><td class="doc"></td></tr></table><h3 id="resolution" class="anchored"><a href="#resolution" class="anchor"></a>Name Resolution</h3><p>This deals with resolving URIs into a list of <a href="index.html#type-endp">endp</a> addresses that can
then be connected to by the <a href="index.html#transport">connection establishment</a> modules.</p><p>All of the name resolvers conform to the <a href="../RESOLVER/index.html">RESOLVER</a> module type.
The OS-specific implementations of this interface are:
</p><table class="modules"><tr id="listing-xref-unresolved-Resolver_lwt" class="anchored"><td class="xref-unresolved"><a href="#listing-xref-unresolved-Resolver_lwt" class="anchor"></a>Resolver_lwt</td><td class="doc"></td></tr><tr id="listing-xref-unresolved-Resolver_lwt_unix" class="anchored"><td class="xref-unresolved"><a href="#listing-xref-unresolved-Resolver_lwt_unix" class="anchor"></a>Resolver_lwt_unix</td><td class="doc"></td></tr><tr id="listing-xref-unresolved-Resolver_mirage" class="anchored"><td class="xref-unresolved"><a href="#listing-xref-unresolved-Resolver_mirage" class="anchor"></a>Resolver_mirage</td><td class="doc"></td></tr></table><div class="spec type" id="type-endp"><a href="#type-endp" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>endp</code><span class="keyword"> = </span><code>[ </code><table class="variant"><tr id="type-endp.TCP" class="anchored"><td class="def constructor"><a href="#type-endp.TCP" class="anchor"></a><code><span class="keyword">| </span></code><code>`TCP<span class="keyword"> of </span>Ipaddr.t<span class="keyword"> * </span>int</code></td></tr><tr id="type-endp.Unix_domain_socket" class="anchored"><td class="def constructor"><a href="#type-endp.Unix_domain_socket" class="anchor"></a><code><span class="keyword">| </span></code><code>`Unix_domain_socket<span class="keyword"> of </span>string</code></td></tr><tr id="type-endp.Vchan_direct" class="anchored"><td class="def constructor"><a href="#type-endp.Vchan_direct" class="anchor"></a><code><span class="keyword">| </span></code><code>`Vchan_direct<span class="keyword"> of </span>int<span class="keyword"> * </span>string</code></td></tr><tr id="type-endp.Vchan_domain_socket" class="anchored"><td class="def constructor"><a href="#type-endp.Vchan_domain_socket" class="anchor"></a><code><span class="keyword">| </span></code><code>`Vchan_domain_socket<span class="keyword"> of </span>string<span class="keyword"> * </span>string</code></td></tr><tr id="type-endp.TLS" class="anchored"><td class="def constructor"><a href="#type-endp.TLS" class="anchor"></a><code><span class="keyword">| </span></code><code>`TLS<span class="keyword"> of </span>string<span class="keyword"> * </span><a href="index.html#type-endp">endp</a></code></td></tr><tr id="type-endp.Unknown" class="anchored"><td class="def constructor"><a href="#type-endp.Unknown" class="anchor"></a><code><span class="keyword">| </span></code><code>`Unknown<span class="keyword"> of </span>string</code></td></tr></table><code> ]</code><code></code></div><div class="doc"><p>End points that can potentially be connected to.
These are typically returned by a call to a <a href="index.html#resolution">resolver</a>.</p></div></div><div class="spec include"><div class="doc"></div><details open="open"><summary><span class="def"><code><span class="keyword">include </span><span class="keyword">sig</span> ... <span class="keyword">end</span></code></span></summary><div class="spec val" id="val-endp_of_sexp"><a href="#val-endp_of_sexp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>endp_of_sexp : Sexplib.Sexp.t <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-endp">endp</a></code></div><div class="doc"></div></div><div class="spec val" id="val-__endp_of_sexp__"><a href="#val-__endp_of_sexp__" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>__endp_of_sexp__ : Sexplib.Sexp.t <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-endp">endp</a></code></div><div class="doc"></div></div><div class="spec val" id="val-sexp_of_endp"><a href="#val-sexp_of_endp" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sexp_of_endp : <a href="index.html#type-endp">endp</a> <span class="keyword">&#8209;&gt;</span> Sexplib.Sexp.t</code></div><div class="doc"></div></div></details></div><div class="spec module-type" id="module-type-IO"><a href="#module-type-IO" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-IO/index.html">IO</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"><p>Module type for cooperative threading that can be satisfied by
Lwt or Async</p></div></div></body></html>