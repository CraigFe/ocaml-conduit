<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>howto (conduit.howto)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="index.html">Up</a> â€“ <a href="index.html">conduit</a> &#x00BB; howto</nav><nav class="toc"><ul><li><a href="#conduit.">Conduit.</a><ul><li><a href="#a-ping-pong-client.">A ping-pong client.</a></li><li><a href="#a-ping-pong-server.">A ping-pong server.</a></li><li><a href="#initiate-a-server-&amp;-a-client.">Initiate a server &amp; a client.</a><ul><li><a href="#compilation-&amp;-run.">Compilation &amp; run.</a></li></ul></li><li><a href="#upgrade-our-protocol-with-crypto.">Upgrade our protocol with crypto.</a><ul><li><a href="#compilation-&amp;-run.">Compilation &amp; run.</a></li></ul></li><li><a href="#conclusion.">Conclusion.</a></li><li><a href="#mirageos-compatibility.">MirageOS compatibility.</a></li></ul></li></ul></nav></header><h2 id="conduit."><a href="#conduit." class="anchor"></a>Conduit.</h2><p><code>Conduit</code> is a library which wants to replace your protocol implementation. Instead to use <span class="xref-unresolved" title="unresolved reference to &quot;Unix.read&quot;"><code>Unix</code>.read</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Unix.write&quot;"><code>Unix</code>.write</span>, we use:</p><ul><li><a href="Conduit/module-type-S/index.html#val-recv"><code>Conduit.S.recv</code></a></li><li><a href="Conduit/module-type-S/index.html#val-send"><code>Conduit.S.send</code></a></li></ul><p>We assume that <code>Conduit</code> is MirageOS-compatible (instead of <code>Unix</code> module).</p><h3 id="a-ping-pong-client."><a href="#a-ping-pong-client." class="anchor"></a>A ping-pong client.</h3><p>We will start with a <code>getline</code> function:</p><pre><code class="ml">val getline : Conduit_lwt.flow -&gt;
  ([ `Line of string | `End_of_flow ], Conduit_lwt.error) result Lwt.t</code></pre><p>As the POSIX <code>getline</code> (see <code>man 3 getline</code>). The ping-pong client sends a line to a ping-pong server and, if it receives then <code>&quot;pong&quot;</code>, it continues to talk until it has nothing to send. Otherwise, it closes the connection.</p><pre><code class="ml">let client ~resolvers edn =
  Conduit_lwt.resolve ~resolvers edn &gt;&gt;? fun flow -&gt;
  let rec go () = match input_line stdin with
    | line -&gt;
      ( Conduit_lwt.send flow (Cstruct.of_string (line ^ &quot;\n&quot;)) &gt;&gt;? fun _ -&gt;
        Format.printf &quot;&gt; %s.\n%!&quot; line ;
        getline flow &gt;&gt;? function
        | `Line &quot;pong&quot; -&gt; Format.printf &quot;&lt; pong.\n%!&quot; ; go ()
        | `Line line -&gt; Format.printf &quot;&lt; %s.\n%!&quot; ; Conduit_lwt.close flow
        | `End_of_flow -&gt; Conduit_lwt.close flow )
    | exception End_of_file -&gt; Conduit_lwt.close flow in
  go ()</code></pre><p><code>getline</code> can be implemented as well with <a href="Conduit/module-type-S/index.html#val-recv"><code>Conduit.S.recv</code></a>.</p><h3 id="a-ping-pong-server."><a href="#a-ping-pong-server." class="anchor"></a>A ping-pong server.</h3><p>A ping-pong server accepts a client and if it receives:</p><ul><li><code>&quot;ping&quot;</code>, it responses <code>&quot;pong&quot;</code></li><li><code>&quot;pong&quot;</code>, it responses <code>&quot;ping&quot;</code></li><li>something else, it responses the received line and it closes the connection</li></ul><p><code>Conduit_lwt</code> (and <code>Conduit_async</code>) provides a simple function <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.serve&quot;"><code>Conduit_lwt</code>.serve</span> to initiate a service. Let's implement the server logic:</p><pre><code class="ml">let handler flow =
  let rec go () =
    getline flow &gt;&gt;= function
    | Ok `End_of_flow | Error _ -&gt; Conduit_lwt.close flow
    | Ok (`Line &quot;ping&quot;) -&gt;
      Conduit_lwt.send flow (Cstruct.of_string &quot;pong\n&quot;) &gt;&gt;? fun _ -&gt; go ()
    | Ok (`Line &quot;pong&quot;) -&gt;
      Conduit_lwt.send flow (Cstruct.of_string &quot;ping\n&quot;) &gt;&gt;? fun _ -&gt; go ()
    | Ok (`Line line) -&gt;
      Conduit_lwt.send flow (Cstruct.of_string (line ^ &quot;\n&quot;)) &gt;&gt;? fun _ -&gt;
      Conduit_lwt.close flow in
  go () &gt;&gt;= function
  | Error err -&gt; failwith &quot;%a&quot; Conduit_lwt.pp_error err
  | Ok () -&gt; Lwt.return_unit

let server cfg ~protocol ~service =
  Conduit_lwt.serve
    ~handler:(fun flow -&gt; handler (Conduit_lwt.pack protocol flow))
    ~service cfg</code></pre><p>Now, we are able to start clients and a simple server. At this stage of the development, we did not choose the protocol implementation (such as a <span class="xref-unresolved" title="unresolved reference to &quot;Unix.socket&quot;"><code>Unix</code>.socket</span>). We will see how to <i>inject</i> a protocol behind <code>Conduit</code>.</p><p>In our code, we use <a href="Conduit/module-type-S/index.html#val-pack"><code>Conduit.S.pack</code></a> which wants to <i>hide</i> the given flow. Indeed, the flow given by <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.serve&quot;"><code>Conduit_lwt</code>.serve</span> has the concrete type <code>Lwt_unix.file_descr</code> so we must <i>abstract</i> it to a <a href="Conduit/module-type-S/index.html#type-flow"><code>Conduit.S.flow</code></a>.</p><h3 id="initiate-a-server-&amp;-a-client."><a href="#initiate-a-server-&amp;-a-client." class="anchor"></a>Initiate a server &amp; a client.</h3><p><code>Conduit_lwt</code> propose a <code>Conduit</code>-compatible TCP/IP protocol: <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP&quot;"><code>Conduit_lwt</code>.TCP</span> (and the same goes for <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_async.TCP&quot;"><code>Conduit_async</code>.TCP</span>). This is your host's TCP/IP stack. Let's launch the ping-pong server with that:</p><pre><code class="ml">let fiber ~uri =
  let host = Uri.host_with_default ~default:&quot;127.0.0.1&quot; uri in
  let port = Option.value ~default:8080 (Uri.port uri) in
  let cfg : Conduit_lwt.TCP.configuration =
    { Conduit_lwt.TCP.sockaddr= Unix.(ADDR_INET (inet_addr_of_string host, port))
    ; capacity= 40 } in
  let _always, run = server cfg
    ~protocol:Conduit_lwt.TCP.protocol
    ~service:Conduit_lwt.TCP.service in
  run ()

let () =
  let uri = Uri.of_string Sys.argv.(1) in  
  Lwt_main.run (fiber ~uri)</code></pre><p>We enforce to use the TCP/IP protocol in that case and we give a service's defined configuration value to launch our ping-pong service. <code>cfg</code> depends on <code>service</code>. Indeed, the type of <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP.service&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP&quot;"><code>Conduit_lwt</code>.TCP</span>.service</span> is:</p><pre><code class="ml">type configuration = { sockaddr : Lwt_unix.sockaddr; capacity : int }

val service : (configuration, Service.t, Protocol.flow) Conduit_lwt.service</code></pre><p>For the client, we must <i>construct</i> a <a href="Conduit/index.html#type-resolvers"><code>Conduit.resolvers</code></a> and give an <a href="Conduit__/Endpoint/index.html#type-t"><code>Conduit.Endpoint.t</code></a>. We will make them from an <span class="xref-unresolved" title="unresolved reference to &quot;Uri.t&quot;"><code>Uri</code>.t</span>:</p><pre><code class="ml">let conduit_of_uri uri =
  let host = Uri.host_with_default ~default:&quot;localhost&quot; uri in
  let port = Option.value ~default:8080 (Uri.port uri) in
  match Uri.scheme uri with
  | Some &quot;pg&quot; | None -&gt;
    let resolvers =
      Conduit.empty
      |&gt; Conduit_lwt.add Conduit_lwt.TCP.protocol (Conduit_lwt.TCP.resolve ~port) in
    resolvers, Conduit_lwt.Endpoint.v host
  | Some scheme -&gt; invalid_arg &quot;Invalid scheme: %s&quot; scheme

let fiber ~uri =
  let resolvers, edn = conduit_of_uri uri in
  client ~resolvers edn &gt;&gt;= function
  | Ok () -&gt; Lwt.return_unit
  | Error err -&gt; failwith &quot;%a&quot; Conduit_lwt.pp_error err

let () =
  let uri = Uri.of_string Sys.argv.(1) in
  Lwt_main.run (fiber ~uri)</code></pre><h4 id="compilation-&amp;-run."><a href="#compilation-&amp;-run." class="anchor"></a>Compilation &amp; run.</h4><p>Let's try our binaries, we use 2 shells (<code>$1&gt;</code> and <code>$2&gt;</code>):</p><pre>$1&gt; ocamlfind opt -thread -linkpkg -package conduit-lwt,uri client.ml -o client
$2&gt; ocamlfind opt -thread -linkpkg -package conduit-lwt,uri server.ml -o server
$2&gt; ./server pg://127.0.0.1/
$1&gt; ./client pg://localhost/
 1&gt; ping
 1&gt; &gt; ping
 1&gt; &lt; ping
 1&gt; pong
 1&gt; &gt; pong
 1&gt; &lt; ping</pre><h3 id="upgrade-our-protocol-with-crypto."><a href="#upgrade-our-protocol-with-crypto." class="anchor"></a>Upgrade our protocol with crypto.</h3><p>It seems that we exchange lot of secret information! So we should upgrade to TLS. At this stage, our <code>server</code> and our <code>client</code> function should <b>not</b> change - and this is the final goal of <code>Conduit</code>: <i>abstract</i> the protocol.</p><p><span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt_tls.TCP&quot;"><code>Conduit_lwt_tls</code>.TCP</span> provides, as <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP&quot;"><code>Conduit_lwt</code>.TCP</span> two values:</p><pre><code class="ml">val protocol :
  ( Lwt_unix.sockaddr * Tls.Config.client,
    Protocol.flow protocol_with_tls )
  protocol

val service :
  ( configuration * Tls.Config.server,
    Service.t service_with_tls,
    Protocol.flow protocol_with_tls )
  service</code></pre><p>So, instead to use <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP.protocol&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP&quot;"><code>Conduit_lwt</code>.TCP</span>.protocol</span> and <span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP.service&quot;"><span class="xref-unresolved" title="unresolved reference to &quot;Conduit_lwt.TCP&quot;"><code>Conduit_lwt</code>.TCP</span>.service</span>, we will use them to upgrade our protocol (when the scheme is <code>&quot;pgs&quot;</code>):</p><pre>server.ml</pre><pre><code class="ml">let load_file filename =
  let ic = open_in filename in
  let ln = in_channel_length ic in
  let rs = Bytes.create ln in
  really_input ic rs 0 ln ;
  close_in ic ;
  Cstruct.of_bytes rs

let config cert key =
  let cert = load_file cert in
  let key = load_file key in
  match
    (X509.Certificate.decode_pem_multiple cert, X509.Private_key.decode_pem key)
  with
  | Ok certs, Ok (`RSA key) -&gt;
      Tls.Config.server ~certificates:(`Single (certs, key)) ()
  | _ -&gt; failwith &quot;Invalid key or certificate&quot;

let fiber ~uri =
  let host = Uri.host_with_default ~default:&quot;127.0.0.1&quot; uri in
  let cfg ~port =
    { Conduit_lwt.TCP.sockaddr= Unix.(ADDR_INET (inet_addr_of_string host, port))
    ; capacity= 40 } in
  let _always, run = match Uri.scheme uri with
    | None | Some &quot;pg&quot; -&gt;
      let port = Option.value ~default:8080 (Uri.port uri) in
      server (cfg ~port)
        ~protocol:Conduit_lwt.TCP.protocol
        ~service:Conduit_lwt.TCP.service
    | Some &quot;pgs&quot; -&gt;
      let port = Option.value ~default:4343 (Uri.port uri) in
      let cfg = cfg ~port, config &quot;server.pem&quot; &quot;server.key&quot; in
      server cfg
        ~protocol:Conduit_lwt_tls.TCP.protocol
        ~service:Conduit_lwt_tls.TCP.service
    | Some scheme -&gt; invalid_arg &quot;Invalid scheme: %s&quot; scheme in
  run ()

let () =
  let uri = Uri.of_string Sys.argv.(1) in  
  Lwt_main.run (fiber ~uri)</code></pre><p>And for the client, we just need to update the function <code>conduit_of_uri</code>:</p><pre>client.ml</pre><pre><code class="ml">let tls_config = Tls.Config.client ~authenticator:(fun ~host:_ _ -&gt; Ok None) ()

let conduit_of_uri uri =
  let host = Uri.host_with_default ~default:&quot;localhost&quot; uri in
  let edn = Conduit_lwt.Endpoint.v host in
  let resolvers = match Uri.scheme uri with
    | Some &quot;pg&quot; -&gt;
      let open Conduit_lwt.TCP in
      let port = Option.value ~default:8080 (Uri.port uri) in 
      let resolvers =
        Conduit.empty
        |&gt; Conduit_lwt.add protocol (TCP.resolve ~port) in
      resolvers
    | Some &quot;pgs&quot; -&gt;
      let open Conduit_lwt_tls.TCP in
      let port = Option.value ~default:4343 (Uri.port uri) in 
      let resolvers =
        Conduit.empty
        |&gt; Conduit_lwt.add protocol (resolve ~port ~config:tls_config) in
      resolvers
    | None -&gt;
      let module TCP = Conduit_lwt.TCP in
      let module TLS = Conduit_lwt_tls.TCP in
      let u_port = Option.value ~default:8080 (Uri.port uri) in 
      let s_port = Option.value ~default:4343 (Uri.port uri) in 
      let resolvers =
        Conduit.empty
        |&gt; Conduit_lwt.add ~priority:10 TLS.protocol
             (TLS.resolve ~port:s_port ~config:tls_config)
        |&gt; Conduit_lwt.add TCP.protocol (TCP.resolve ~port:u_port) in
      resolvers
    | Some scheme -&gt; Fmt.invalid_arg &quot;Invalid scheme: %s&quot; scheme in
  resolvers, edn</code></pre><p>Above, we can see that for the default case (when we don't have a scheme), we <i>inject</i> two protocols, the secure one (with a priority) and the unsecure one. <code>Conduit</code> will try the secure one and if it fails, it fallbacks to the second one. This case can appear when you want to communicate with a peer and you have multiple possibilies such as <code>http</code> and <code>https</code>.</p><h4 id="compilation-&amp;-run."><a href="#compilation-&amp;-run." class="anchor"></a>Compilation &amp; run.</h4><p>Let's show result:</p><pre>$1&gt; ocamlfind opt -thread -linkpkg -package conduit-lwt-tls,mirage-crypto-rng.unix \
  client.ml -o client
$2&gt; ocamlfind opt -thread -linkpkg -package conduit-lwt-tls,mirage-crypto-rng.unix \
  server.ml -o server
$2&gt; ./server pgs://127.0.0.1/
$1&gt; ./client localhost
 1&gt; pong
 1&gt; &gt; pong
 1&gt; &lt; ping</pre><h3 id="conclusion."><a href="#conclusion." class="anchor"></a>Conclusion.</h3><p>From a client logic and a server logic, with <code>Conduit</code>, we are able to abstract both over the protocol implementation. <code>Conduit</code> comes with several implementations (TCP/IP, TLS and SSL) but a protocol implementer can add its own protocol implementation only with the core of <code>Conduit</code>.</p><p>Then, from the user point-of-view, he can decide which protocol he wants to use. We see that upgrading a existing code-base to another protocol has no cost as long as the code-base use <code>Conduit</code>.</p><p>Of course, the end-user (our <code>fiber</code> functions) must be updated according new protocols but it does not imply any change on the logic of the server and the logic of the client: this is the goal of <code>Conduit</code>!</p><h3 id="mirageos-compatibility."><a href="#mirageos-compatibility." class="anchor"></a>MirageOS compatibility.</h3><p>For MirageOS, it's hard to abstract the entire stack with <i>functors</i> to be able to launch a simple HTTP request - and it's even more difficult with a (non-required) cryptographic layered protocol such as TLS. <code>Conduit</code> should help users and protocol implementers to be compatible with MirageOS.</p><p>As you can see, <code>Conduit</code> is not mandatory at the logic of your protocol and you are able to <i>functorize</i> this part with something close to <a href="Conduit/module-type-S/index.html"><code>Conduit.S</code></a> (as <code>cohttp</code> does). The application of your <i>functor</i> with <code>Conduit</code> lets the user to orchestrate your implementation with others protocols (such as <code>mirage-tcpip</code>) without anothers <i>functors</i>.</p><p>Of course, <code>Conduit</code> is not only about MirageOS when the question of the abstraction can appear for anyone: which TLS implementation should I use? Should I enforce one of them? Again, it's about abstraction and <code>Conduit</code> is a response about that more generally.</p></div></body></html>